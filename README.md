# AoA-Project2

## Network Flow Case: Tutor Allocation via Max-Flow

### 1. Real-World Problem

A university tutoring center must assign student study groups to available tutors. Each student group requires a specific number of hours, and each tutor has a limited number of available hours. Due to subject expertise or schedule constraints, only certain tutors are compatible with certain student groups.

This is the **Tutor Allocation** problem: assign tutoring hours to maximize the total service provided without exceeding student demands or tutor availability constraints.

### 2. Repository Files

- **TutorAllocation.java** Contains the core logic for the **Edmonds-Karp Max-Flow algorithm**. It constructs the bipartite flow network based on student/tutor data, solves for the maximum flow to determine the optimal schedule, and runs experiments to generate performance data (CSV).

- **plot_tutor.py** Python plotting script that reads the experimental results (`tutor_results.csv`) generated by the Java program and visualizes the runtime performance (Runtime vs. Number of Groups).

### 3. Network Flow Reduction

- **Formulation.** The problem is modeled as a **Bipartite Matching with Demands and Supplies**. Student groups form one set of nodes (demand side), and tutors form the other (supply side). Edges represent valid compatibility.
- **Reduction.** We reduce this to a **Max-Flow** problem. A global Source connects to all student groups with capacity equal to their demand hours. All tutors connect to a global Sink with capacity equal to their available hours. Compatible student-tutor pairs are connected with infinite capacity. The maximum flow from Source to Sink corresponds exactly to the maximum feasible tutoring hours.
- **Algorithm.** We implement the **Edmonds-Karp** algorithm. It uses Breadth-First Search (BFS) to find augmenting paths in the residual graph, ensuring the algorithm terminates with the optimal max-flow assignment.
- **Experiment.** The Java implementation verifies the theoretical complexity. Experiments on random datasets show that the runtime scales polynomially with the input size ($O(VE^2)$ worst-case), confirming the efficiency of the reduction for real-world scheduling sizes.

## NP-Complete Case: Minimal Budgeted Curriculum Cover with Constraints

### 1. Real-World Problem
Students facing job-market pressure must assemble a minimal set of online courses to cover all required skills (e.g., Java, Docker, Spring Boot, SQL, Microservices) while respecting practical limits:
- **Budget** (total course fees),
- **Time** (total course hours),
- **Quality** (minimum rating per course).

This is the **Minimal Budgeted Curriculum Cover** problem: select the fewest courses whose combined skills cover all requirements without violating budget/time/quality constraints.

### 2. Repository Files
- **CourseData.java**  
  Data model for courses (skills taught, price, duration, rating) and required skills. Handles parsing/holding instances used by the algorithms.

- **GreedySkillCover.java**  
  Implements the greedy course-selection heuristic (e.g., maximizing newly covered skills per cost unit under constraints). Core solver.

- **GreedyCoverExperiment.java**  
  Experimental harness to generate or load instances, run the greedy solver, record runtime/solution size, and write results (e.g., CSV) for plotting.

- **GreedyUtils.java**  
  Utility helpers: set operations on skills, scoring functions, constraint checks (budget/time/rating), and general support routines.

- **outputPicture.py**  
  Python plotting script to visualize experimental results (e.g., runtime vs. skills/courses, selected courses vs. skill count) from the CSV logs.

### 3. NP-Complete Reduction 
- **Formulation.** Treat the required skills as the universe. Each course corresponds to a subset of skills and carries attributes: price, duration, and rating. Constraints require total price within the budget, total duration within the time limit, and each chosen course meeting the rating threshold. The goal is to pick the fewest courses whose combined skills cover all requirements while respecting these constraints.
- **NP-hardness.** Classic Set Cover is a special case when the constraints are non-restrictive (zero costs/durations, permissive budgets/time, and low rating threshold). Since Set Cover is NP-complete, this constrained version is NP-hard.
- **In NP.** Given a candidate set of courses, checking that all skills are covered and that budget/time/rating constraints hold can be done in polynomial time. Therefore, the decision version is NP-complete.
- **Heuristic.** Exact solutions are infeasible at scale, so a greedy algorithm is used to find a near-good solution efficiently under the constraints. Experiments show runtime growth consistent with the expected scan complexity over courses and skills.
